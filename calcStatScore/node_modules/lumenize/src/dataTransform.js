// Generated by CoffeeScript 1.9.3
(function() {
  var Time, arrayOfMaps_To_CSVStyleArray, arrayOfMaps_To_HighChartsSeries, csvString_To_CSVStyleArray, csvStyleArray_To_ArrayOfMaps, csvStyleArray_To_CSVString, ref, utils;

  ref = require('tztime'), utils = ref.utils, Time = ref.Time;

  csvStyleArray_To_ArrayOfMaps = function(csvStyleArray, rowKeys) {

    /*
    @method csvStyleArray_To_ArrayOfMaps
    @param {Array[]} csvStyleArray The first row is usually the list of column headers but if not, you can
      provide your own such list in the second parameter
    @param {String[]} [rowKeys] specify the column headers like `['column1', 'column2']`. If not provided, it will use
      the first row of the csvStyleArray
    @return {Object[]}
    
    `csvStyleArry_To_ArryOfMaps` is a convenience function that will convert a csvStyleArray like:
    
        {csvStyleArray_To_ArrayOfMaps} = require('../')
    
        csvStyleArray = [
          ['column1', 'column2'],
          [1         , 2       ],
          [3         , 4       ],
          [5         , 6       ]
        ]
    
    to an Array of Maps like this:
    
        console.log(csvStyleArray_To_ArrayOfMaps(csvStyleArray))
    
         * [ { column1: 1, column2: 2 },
         *   { column1: 3, column2: 4 },
         *   { column1: 5, column2: 6 } ]
     */
    var arrayOfMaps, i, index, inputRow, j, key, len, outputRow, tableLength;
    arrayOfMaps = [];
    if (rowKeys != null) {
      i = 0;
    } else {
      rowKeys = csvStyleArray[0];
      i = 1;
    }
    tableLength = csvStyleArray.length;
    while (i < tableLength) {
      inputRow = csvStyleArray[i];
      outputRow = {};
      for (index = j = 0, len = rowKeys.length; j < len; index = ++j) {
        key = rowKeys[index];
        outputRow[key] = inputRow[index];
      }
      arrayOfMaps.push(outputRow);
      i++;
    }
    return arrayOfMaps;
  };

  arrayOfMaps_To_CSVStyleArray = function(arrayOfMaps, fields) {

    /*
    @method arrayOfMaps_To_CSVStyleArray
    @param {Object[]} arrayOfMaps
    @param {String[]} [fields] If not provided, it will use the first row and get all fields
    @return {Array[]} The first row will be the column headers
    
       `arrayOfMaps_To_CSVStyleArray` is a convenience function that will convert an array of maps like:
    
        {arrayOfMaps_To_CSVStyleArray} = require('../')
    
        arrayOfMaps = [
          {column1: 10000, column2: 20000},
          {column1: 30000, column2: 40000},
          {column1: 50000, column2: 60000}
        ]
    
    to a CSV-style array like this:
    
        console.log(arrayOfMaps_To_CSVStyleArray(arrayOfMaps))
    
         * [ [ 'column1', 'column2' ],
         *   [ 10000, 20000 ],
         *   [ 30000, 40000 ],
         *   [ 50000, 60000 ] ]
     */
    var csvStyleArray, inRow, j, k, key, len, len1, outRow, ref1, value;
    if (arrayOfMaps.length === 0) {
      return [];
    }
    csvStyleArray = [];
    outRow = [];
    if (fields == null) {
      fields = [];
      ref1 = arrayOfMaps[0];
      for (key in ref1) {
        value = ref1[key];
        fields.push(key);
      }
    }
    csvStyleArray.push(fields);
    for (j = 0, len = arrayOfMaps.length; j < len; j++) {
      inRow = arrayOfMaps[j];
      outRow = [];
      for (k = 0, len1 = fields.length; k < len1; k++) {
        key = fields[k];
        outRow.push(inRow[key]);
      }
      csvStyleArray.push(outRow);
    }
    return csvStyleArray;
  };

  arrayOfMaps_To_HighChartsSeries = function(arrayOfMaps, config) {

    /*
    @method arrayOfMaps_To_HighChartsSeries
    @param {Array[]} arrayOfMaps
    @param {Object} config You can use the same config you used to call TimeSeriesCalculator including your yAxis specifications
    @return {Object[]} in HighCharts form
    
    Takes an array of arrays that came from a call to TimeSeriesCalculator and looks like this:
    
        {arrayOfMaps_To_HighChartsSeries} = require('../')
    
        arrayOfMaps = [
          {"Series 1": 8, "Series 2": 5, "Series3": 10},
          {"Series 1": 2, "Series 2": 3},
          {"Series 1": 1, "Series 2": 2, "Series3": 40},
        ]
    
    and a list of series configurations
    
        config = [
          {name: "Series 1", yAxis: 1},
          {name: "Series 2"},
          {name: "Series3"}
        ]
    
    and extracts the data into seperate series
    
        console.log(arrayOfMaps_To_HighChartsSeries(arrayOfMaps, config))
         * [ { name: 'Series 1', data: [ 8, 2, 1 ], yAxis: 1 },
         *   { name: 'Series 2', data: [ 5, 3, 2 ] },
         *   { name: 'Series3', data: [ 10, null, 40 ] } ]
    
    Notice how the extra fields from the series array are included in the output. Also, notice how the missing second
    value for Series3 was replaced with a null. HighCharts will skip right over this for category charts as you would
    expect.
     */
    var a, aggregationRow, idx, j, k, key, l, len, len1, len2, len3, m, output, outputRow, preOutput, s, seriesNames, seriesRow, value;
    preOutput = {};
    seriesNames = [];
    for (j = 0, len = config.length; j < len; j++) {
      a = config[j];
      seriesNames.push(a.name);
    }
    for (k = 0, len1 = seriesNames.length; k < len1; k++) {
      s = seriesNames[k];
      preOutput[s] = [];
      for (l = 0, len2 = arrayOfMaps.length; l < len2; l++) {
        aggregationRow = arrayOfMaps[l];
        value = aggregationRow[s];
        if (value == null) {
          value = null;
        }
        preOutput[s].push(value);
      }
    }
    output = [];
    for (idx = m = 0, len3 = seriesNames.length; m < len3; idx = ++m) {
      s = seriesNames[idx];
      outputRow = {
        name: s,
        data: preOutput[s]
      };
      seriesRow = config[idx];
      for (key in seriesRow) {
        value = seriesRow[key];
        if (key !== 'name' && key !== 'data') {
          outputRow[key] = value;
        }
      }
      output.push(outputRow);
    }
    return output;
  };

  csvString_To_CSVStyleArray = function(s, asterixForUndefined) {
    var c, cValue, error, headerLength, index, j, k, len, len1, newRow, out, rawRowArray, row, rows;
    if (asterixForUndefined == null) {
      asterixForUndefined = true;
    }
    rows = s.split('\n');
    headerLength = rows[0].split(',').length;
    out = [];
    for (index = j = 0, len = rows.length; j < len; index = ++j) {
      row = rows[index];
      newRow = [];
      rawRowArray = row.split(',');
      if (rawRowArray.length === headerLength) {
        for (k = 0, len1 = rawRowArray.length; k < len1; k++) {
          c = rawRowArray[k];
          if (asterixForUndefined && c === '*') {
            cValue = void 0;
          } else {
            try {
              cValue = JSON.parse(c);
            } catch (_error) {
              error = _error;
            }
          }
          newRow.push(cValue);
        }
        out.push(newRow);
      } else {
        console.log("Warning: Skipping row because length does not match header length in row " + index + ": " + row);
      }
    }
    return out;
  };

  csvStyleArray_To_CSVString = function(csvStyleArray) {
    var j, k, len, len1, row, s, value;
    s = '';
    for (j = 0, len = csvStyleArray.length; j < len; j++) {
      row = csvStyleArray[j];
      for (k = 0, len1 = row.length; k < len1; k++) {
        value = row[k];
        s += JSON.stringify(value) + ', ';
      }
      s += "\n";
    }
    return s;
  };

  exports.arrayOfMaps_To_CSVStyleArray = arrayOfMaps_To_CSVStyleArray;

  exports.csvStyleArray_To_ArrayOfMaps = csvStyleArray_To_ArrayOfMaps;

  exports.arrayOfMaps_To_HighChartsSeries = arrayOfMaps_To_HighChartsSeries;

  exports.csvString_To_CSVStyleArray = csvString_To_CSVStyleArray;

  exports.csvStyleArray_To_CSVString = csvStyleArray_To_CSVString;

}).call(this);

//# sourceMappingURL=dataTransform.js.map
