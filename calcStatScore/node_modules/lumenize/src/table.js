// Generated by CoffeeScript 1.9.3
(function() {
  var table, utils;

  utils = require('tztime').utils;

  table = {};


  /*
  @class table
   */

  table.padToWidth = function(s, width, padCharacter, rightPad) {
    var padding;
    if (padCharacter == null) {
      padCharacter = ' ';
    }
    if (rightPad == null) {
      rightPad = false;
    }
    if (s.length > width) {
      return s.substr(0, width);
    }
    padding = new Array(width - s.length + 1).join(padCharacter);
    if (rightPad) {
      return s + padding;
    } else {
      return padding + s;
    }
  };

  table.toString = function(rows, fields, sortBy, descending) {
    var field, i, index, j, k, key, l, len, len1, len2, len3, len4, len5, m, maxWidths, n, ref, ref1, ref2, row, s, sortedRows, value;
    if (descending == null) {
      descending = false;
    }

    /*
    @method toString
    @param {Object[]} rows
    @param {Object} [fields] If not provided, it will use the fields found in the first row
    @param {String} [sortBy] If provided, it will sort the table by this field before returning
    @param {Boolean} [descending = false] By default, the sort will be ascending, setting this to true will sort descending
    @return {String} Returns a string for the table in Markdown format
    
        t = [
          {col1: 'hello', col2: 12, col3: true},
          {col1: 'goodbye', col2: 120, col3: false},
          {col1: 'yep', col2: -23, col3: true},
        ]
    
        console.log(require('../').table.toString(t, null, 'col2', true))
         * | col1    | col2 | col3  |
         * | ------- | ---- | ----- |
         * | goodbye | 120  | false |
         * | hello   | 12   | true  |
         * | yep     | -23  | true  |
     */
    if (fields == null) {
      fields = [];
      ref = rows[0];
      for (key in ref) {
        value = ref[key];
        fields.push(key);
      }
    }
    maxWidths = [];
    for (index = i = 0, len = fields.length; i < len; index = ++i) {
      field = fields[index];
      maxWidths.push(field.length);
      for (j = 0, len1 = rows.length; j < len1; j++) {
        row = rows[j];
        maxWidths[index] = Math.max(maxWidths[index], ((ref1 = row[field]) != null ? ref1.toString().length : void 0) || 0);
      }
    }
    if (sortBy != null) {
      sortedRows = utils._.sortBy(rows, sortBy);
      if (descending) {
        sortedRows = sortedRows.reverse();
      }
    } else {
      sortedRows = rows;
    }
    s = '|';
    for (index = k = 0, len2 = fields.length; k < len2; index = ++k) {
      field = fields[index];
      s += ' ';
      s += table.padToWidth(field, maxWidths[index], void 0, true) + ' |';
    }
    s += '\n|';
    for (index = l = 0, len3 = fields.length; l < len3; index = ++l) {
      field = fields[index];
      s += ' ';
      s += table.padToWidth('', maxWidths[index], '-', true) + ' |';
    }
    for (m = 0, len4 = sortedRows.length; m < len4; m++) {
      row = sortedRows[m];
      s += '\n|';
      for (index = n = 0, len5 = fields.length; n < len5; index = ++n) {
        field = fields[index];
        s += ' ';
        s += table.padToWidth(((ref2 = row[field]) != null ? ref2.toString() : void 0) || '', maxWidths[index], void 0, true) + ' |';
      }
    }
    return s;
  };

  exports.table = table;

}).call(this);

//# sourceMappingURL=table.js.map
