// Generated by CoffeeScript 1.9.2
(function() {
  var DocumentClient, WrappedClient, WrappedQueryIterator, _, async, delay, wrapCallbackMethod, wrapExecuteStoredProcedure, wrapMultiMethod, wrapQueryIteratorMethod, wrapQueryIteratorMethodForArray, wrapSimpleMethod, wrapToArray, wrapToCreateAsyncJSIterator,
    slice = [].slice;

  _ = require('lodash');

  async = require('async');

  DocumentClient = require('documentdb').DocumentClient;

  delay = function(ms, func) {
    return setTimeout(func, ms);
  };

  WrappedQueryIterator = (function() {
    function _Class(_iterator1, defaultRetries1) {
      var _method, methodName, ref;
      this._iterator = _iterator1;
      this.defaultRetries = defaultRetries1;
      ref = this._iterator;
      for (methodName in ref) {
        _method = ref[methodName];
        if (methodName === 'executeNext' || methodName === 'forEach' || methodName === 'nextItem') {
          this[methodName] = wrapCallbackMethod(this._iterator, _method, this.defaultRetries);
        } else if (methodName === 'toArray') {
          this[methodName] = wrapToArray(this);
        } else {
          this[methodName] = wrapSimpleMethod(this._iterator, _method);
        }
      }
    }

    return _Class;

  })();

  wrapQueryIteratorMethod = function(_client, _method, defaultRetries) {
    var f;
    f = function() {
      var _iterator, parameters;
      parameters = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      _iterator = _method.call.apply(_method, [_client].concat(slice.call(parameters)));
      return new WrappedQueryIterator(_iterator, defaultRetries);
    };
    return f;
  };

  wrapQueryIteratorMethodForArray = function(_client, _method, defaultRetries) {
    var f;
    f = function() {
      var _iterator, callback, iterator, parameters;
      parameters = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      callback = parameters.pop();
      _iterator = _method.call.apply(_method, [_client].concat(slice.call(parameters)));
      iterator = new WrappedQueryIterator(_iterator, defaultRetries);
      return iterator.toArray(callback);
    };
    return f;
  };

  wrapToArray = function(iterator) {
    var f;
    f = function(callback) {
      var all, innerF, pages;
      all = [];
      pages = 0;
      innerF = function() {
        return iterator.executeNext(function(err, response, headers, retries) {
          if (err != null) {
            return callback(err, response, headers, pages);
          } else {
            pages++;
            all = all.concat(response);
            if (iterator.hasMoreResults()) {
              return innerF();
            } else {
              return callback(err, all, headers, pages);
            }
          }
        });
      };
      return innerF();
    };
    return f;
  };

  wrapSimpleMethod = function(that, _method) {
    var f;
    f = function() {
      var parameters;
      parameters = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      return _method.call.apply(_method, [that].concat(slice.call(parameters)));
    };
    return f;
  };

  wrapToCreateAsyncJSIterator = function(that, _method) {
    var f;
    f = function(item, callback) {
      return _method.call.apply(_method, [that].concat(slice.call(item), [function(err, response, headers, other) {
        return callback(err, {
          response: response,
          headers: headers,
          other: other
        });
      }]));
    };
    return f;
  };

  wrapMultiMethod = function(that, asyncJSIterator) {
    var f;
    f = function() {
      var callback, items, link, linkArray, parameters;
      parameters = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      callback = parameters.pop();
      linkArray = parameters.shift();
      if (!_.isArray(linkArray)) {
        linkArray = [linkArray];
      }
      items = (function() {
        var i, len, results1;
        results1 = [];
        for (i = 0, len = linkArray.length; i < len; i++) {
          link = linkArray[i];
          results1.push([link].concat(parameters));
        }
        return results1;
      })();
      return async.map(items, asyncJSIterator, function(err, results) {
        var concatenatedResults, headers, i, len, result, stats;
        concatenatedResults = [];
        stats = {
          roundTripCount: 0,
          itemCount: 0,
          requestUnitCharges: 0
        };
        for (i = 0, len = results.length; i < len; i++) {
          result = results[i];
          if (_.isArray(result.response)) {
            concatenatedResults = concatenatedResults.concat(result.response);
          } else {
            concatenatedResults.push(result.response);
          }
          headers = result.headers;
          stats.roundTripCount += result.other;
          stats.itemCount += Number(headers['x-ms-item-count']);
          stats.requestUnitCharges += Number(headers['x-ms-request-charge']);
        }
        if (_.isNaN(stats.roundTripCount)) {
          delete stats.roundTripCount;
        }
        if (_.isNaN(stats.itemCount)) {
          delete stats.itemCount;
        }
        return callback(err, concatenatedResults, stats);
      });
    };
    return f;
  };

  wrapCallbackMethod = function(that, _method, defaultRetries) {
    var f, retries;
    retries = 0;
    f = function() {
      var callback, innerF, parameters;
      parameters = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      callback = parameters.pop();
      innerF = function() {
        var parameters, retriesLeft;
        retriesLeft = arguments[0], parameters = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (retriesLeft == null) {
          retriesLeft = defaultRetries;
        }
        return _method.call.apply(_method, [that].concat(slice.call(parameters), [function(err, response, headers) {
          var ref, retryAfter;
          if (err != null) {
            if (((ref = err.code) === 429 || ref === 449) && retriesLeft > 0) {
              retryAfter = headers['x-ms-retry-after-ms'] || 1;
              retryAfter = Number(retryAfter);
              retries++;
              delay(retryAfter, function() {
                return innerF.apply(null, [retriesLeft - 1].concat(slice.call(parameters)));
              });
            } else {
              return callback(err, response, headers, retries);
            }
          } else {
            return callback(err, response, headers, retries);
          }
        }]));
      };
      return innerF.apply(null, [null].concat(slice.call(parameters)));
    };
    return f;
  };

  wrapExecuteStoredProcedure = function(_client, _method, defaultRetries) {
    var f;
    f = function() {
      var callback, innerF, parameters;
      parameters = 1 <= arguments.length ? slice.call(arguments, 0) : [];
      callback = parameters.pop();
      innerF = function() {
        var parameters, retriesLeft;
        retriesLeft = arguments[0], parameters = 2 <= arguments.length ? slice.call(arguments, 1) : [];
        if (retriesLeft == null) {
          retriesLeft = defaultRetries;
        }
        return _method.call.apply(_method, [_client].concat(slice.call(parameters), [function(err, response, headers) {
          var ref, retryAfter;
          if (err != null) {
            if (((ref = err.code) === 429 || ref === 449) && retriesLeft > 0) {
              retryAfter = headers['x-ms-retry-after-ms'] || 1;
              retryAfter = Number(retryAfter);
              delay(retryAfter, function() {
                return innerF.apply(null, [retriesLeft - 1].concat(slice.call(parameters)));
              });
            } else {
              return callback(err, response, headers);
            }
          } else {
            if (response.continuation != null) {
              parameters[1] = response;
              return innerF.apply(null, [null].concat(slice.call(parameters)));
            } else {
              return callback(err, response, headers);
            }
          }
        }]));
      };
      return innerF.apply(null, [null].concat(slice.call(parameters)));
    };
    return f;
  };

  module.exports = WrappedClient = (function() {
    function WrappedClient(urlConnection, auth, connectionPolicy, consistencyLevel) {
      var _method, asyncJSMethod, firstParameterIsLink, hasArrayVersion, indexOfLeftParen, indexOfRightParen, lastParameterIsCallback, masterKey, methodName, methodNameToWrap, methodSpec, parameterList, parameterListString, ref;
      this.urlConnection = urlConnection;
      this.auth = auth;
      this.connectionPolicy = connectionPolicy;
      this.consistencyLevel = consistencyLevel;
      if (this.urlConnection instanceof DocumentClient) {
        this._client = this.urlConnection;
      } else {
        this.urlConnection = this.urlConnection || process.env.DOCUMENT_DB_URL;
        masterKey = process.env.DOCUMENT_DB_KEY;
        this.auth = this.auth || {
          masterKey: masterKey
        };
        this._client = new DocumentClient(this.urlConnection, this.auth, this.connectionPolicy, this.consistencyLevel);
      }
      this.defaultRetries = 3;
      ref = this._client;
      for (methodName in ref) {
        _method = ref[methodName];
        if (typeof _method !== 'function') {
          continue;
        }
        hasArrayVersion = _.startsWith(methodName, 'query') || _.startsWith(methodName, 'read') && _.endsWith(methodName, 's');
        methodSpec = _method.toString().split('\n')[0];
        indexOfLeftParen = methodSpec.indexOf('(');
        indexOfRightParen = methodSpec.indexOf(')');
        parameterListString = methodSpec.substr(indexOfLeftParen + 1, indexOfRightParen - indexOfLeftParen - 1);
        parameterList = parameterListString.split(', ');
        firstParameterIsLink = _.endsWith(parameterList[0], 'Link');
        lastParameterIsCallback = parameterList[parameterList.length - 1] === 'callback';
        if (methodName === 'executeStoredProcedure') {
          this[methodName] = wrapExecuteStoredProcedure(this._client, _method, this.defaultRetries);
        } else if (lastParameterIsCallback) {
          this[methodName] = wrapCallbackMethod(this._client, _method, this.defaultRetries);
        } else if (hasArrayVersion) {
          this[methodName] = wrapQueryIteratorMethod(this._client, _method, this.defaultRetries);
          this[methodName + 'Array'] = wrapQueryIteratorMethodForArray(this._client, _method, this.defaultRetries);
        } else {

        }
        if (firstParameterIsLink) {
          if (hasArrayVersion) {
            methodNameToWrap = methodName + 'Array';
          } else {
            methodNameToWrap = methodName;
          }
          asyncJSMethod = wrapToCreateAsyncJSIterator(this, this[methodNameToWrap]);
          this[methodNameToWrap + 'AsyncJSIterator'] = asyncJSMethod;
          this[methodNameToWrap + 'Multi'] = wrapMultiMethod(this, asyncJSMethod);
        }
      }
    }

    return WrappedClient;

  })();

}).call(this);
