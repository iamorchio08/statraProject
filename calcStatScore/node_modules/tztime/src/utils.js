// Generated by CoffeeScript 1.9.3
(function() {
  var AssertException, ErrorBase, assert, clone, compare, decodeUtf8, encodeUtf8, exactMatch, filterMatch, isArray, keys, log, lzwDecode, lzwEncode, match, startsWith, trim, type, values,
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  exports.MAX_INT = 2147483647;

  exports.MIN_INT = -2147483648;

  ErrorBase = (function(superClass) {
    extend(ErrorBase, superClass);

    function ErrorBase(message1) {
      this.message = message1 != null ? message1 : 'Unknown error.';
      if (Error.captureStackTrace != null) {
        Error.captureStackTrace(this, this.constructor);
      }
      this.name = this.constructor.name;
    }

    ErrorBase.prototype.toString = function() {
      return this.name + ": " + this.message;
    };

    return ErrorBase;

  })(Error);

  AssertException = (function(superClass) {
    extend(AssertException, superClass);

    function AssertException() {
      return AssertException.__super__.constructor.apply(this, arguments);
    }

    return AssertException;

  })(ErrorBase);

  assert = function(exp, message) {
    if (!exp) {
      throw new exports.AssertException(message);
    }
  };

  match = function(obj1, obj2) {
    var key, value;
    for (key in obj1) {
      value = obj1[key];
      if (value !== obj2[key]) {
        return false;
      }
    }
    return true;
  };

  exactMatch = function(a, b) {
    var atype, btype, key, val;
    if (a === b) {
      return true;
    }
    atype = typeof a;
    btype = typeof b;
    if (atype !== btype) {
      return false;
    }
    if ((!a && b) || (a && !b)) {
      return false;
    }
    if (atype !== 'object') {
      return false;
    }
    if (a.length && (a.length !== b.length)) {
      return false;
    }
    for (key in a) {
      val = a[key];
      if (!(key in b) || !exactMatch(val, b[key])) {
        return false;
      }
    }
    return true;
  };

  filterMatch = function(obj1, obj2) {
    var key, value;
    if (!(type(obj1) === 'object' && type(obj2) === 'object')) {
      throw new Error('obj1 and obj2 must both be objects when calling filterMatch');
    }
    for (key in obj1) {
      value = obj1[key];
      if (!exactMatch(value, obj2[key])) {
        return false;
      }
    }
    return true;
  };

  trim = function(val) {
    if (String.prototype.trim != null) {
      return val.trim();
    } else {
      return val.replace(/^\s+|\s+$/g, "");
    }
  };

  startsWith = function(bigString, potentialStartString) {
    return bigString.substring(0, potentialStartString.length) === potentialStartString;
  };

  isArray = function(a) {
    return Object.prototype.toString.apply(a) === '[object Array]';
  };

  type = (function() {
    var classToType, j, len, name, ref;
    classToType = {};
    ref = "Boolean Number String Function Array Date RegExp Undefined Null".split(" ");
    for (j = 0, len = ref.length; j < len; j++) {
      name = ref[j];
      classToType["[object " + name + "]"] = name.toLowerCase();
    }
    return function(obj) {
      var strType;
      strType = Object.prototype.toString.call(obj);
      return classToType[strType] || "object";
    };
  })();

  clone = function(obj) {
    var flags, key, newInstance;
    if ((obj == null) || typeof obj !== 'object') {
      return obj;
    }
    if (obj instanceof Date) {
      return new Date(obj.getTime());
    }
    if (obj instanceof RegExp) {
      flags = '';
      if (obj.global != null) {
        flags += 'g';
      }
      if (obj.ignoreCase != null) {
        flags += 'i';
      }
      if (obj.multiline != null) {
        flags += 'm';
      }
      if (obj.sticky != null) {
        flags += 'y';
      }
      return new RegExp(obj.source, flags);
    }
    newInstance = new obj.constructor();
    for (key in obj) {
      newInstance[key] = clone(obj[key]);
    }
    return newInstance;
  };

  keys = Object.keys || function(obj) {
    var key, val;
    return (function() {
      var results;
      results = [];
      for (key in obj) {
        val = obj[key];
        results.push(key);
      }
      return results;
    })();
  };

  values = function(obj) {
    var key, val;
    return (function() {
      var results;
      results = [];
      for (key in obj) {
        val = obj[key];
        results.push(val);
      }
      return results;
    })();
  };

  log = function(s) {
    var pre;
    if ((typeof document !== "undefined" && document !== null ? document.createElement : void 0) != null) {
      pre = document.createElement('pre');
      pre.innerHTML = s;
      return document.body.appendChild(pre);
    } else {
      return console.log(s);
    }
  };

  compare = function(a, b) {
    var aString, bString, index, j, len, value;
    if (a === null) {
      return 1;
    }
    if (b === null) {
      return -1;
    }
    switch (type(a)) {
      case 'number':
      case 'boolean':
      case 'date':
        return b - a;
      case 'array':
        for (index = j = 0, len = a.length; j < len; index = ++j) {
          value = a[index];
          if (b.length - 1 >= index && value < b[index]) {
            return 1;
          }
          if (b.length - 1 >= index && value > b[index]) {
            return -1;
          }
        }
        if (a.length < b.length) {
          return 1;
        } else if (a.length > b.length) {
          return -1;
        } else {
          return 0;
        }
        break;
      case 'object':
      case 'string':
        aString = JSON.stringify(a);
        bString = JSON.stringify(b);
        if (aString < bString) {
          return 1;
        } else if (aString > bString) {
          return -1;
        } else {
          return 0;
        }
        break;
      default:
        throw new Error("Do not know how to sort objects of type " + (utils.type(a)) + ".");
    }
  };

  encodeUtf8 = function(s) {
    return unescape(encodeURIComponent(s));
  };

  decodeUtf8 = function(s) {
    return decodeURIComponent(escape(s));
  };

  lzwEncode = function(s) {
    var code, currChar, data, dict, i, out, phrase;
    s = encodeUtf8(s);
    dict = {};
    data = (s + "").split("");
    out = [];
    currChar = void 0;
    phrase = data[0];
    code = 256;
    i = 1;
    while (i < data.length) {
      currChar = data[i];
      if (dict[phrase + currChar] != null) {
        phrase += currChar;
      } else {
        out.push((phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0)));
        dict[phrase + currChar] = code;
        code++;
        phrase = currChar;
      }
      i++;
    }
    out.push((phrase.length > 1 ? dict[phrase] : phrase.charCodeAt(0)));
    i = 0;
    while (i < out.length) {
      out[i] = String.fromCharCode(out[i]);
      i++;
    }
    return out.join("");
  };

  lzwDecode = function(s) {
    var code, currChar, currCode, data, dict, i, oldPhrase, out, outS, phrase;
    dict = {};
    data = (s + "").split("");
    currChar = data[0];
    oldPhrase = currChar;
    out = [currChar];
    code = 256;
    phrase = void 0;
    i = 1;
    while (i < data.length) {
      currCode = data[i].charCodeAt(0);
      if (currCode < 256) {
        phrase = data[i];
      } else {
        phrase = (dict[currCode] ? dict[currCode] : oldPhrase + currChar);
      }
      out.push(phrase);
      currChar = phrase.charAt(0);
      dict[code] = oldPhrase + currChar;
      code++;
      oldPhrase = phrase;
      i++;
    }
    outS = out.join("");
    return decodeUtf8(outS);
  };

  exports.log = log;

  exports.AssertException = AssertException;

  exports.assert = assert;

  exports.match = match;

  exports.filterMatch = filterMatch;

  exports.trim = trim;

  exports.startsWith = startsWith;

  exports.isArray = isArray;

  exports.type = type;

  exports.clone = clone;

  exports.keys = keys;

  exports.values = values;

  exports.compare = compare;

  exports.lzwEncode = lzwEncode;

  exports.lzwDecode = lzwDecode;

  exports._ = require('underscore');

}).call(this);
